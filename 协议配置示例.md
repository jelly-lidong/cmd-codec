# 协议配置示例大全

本文档提供了完整的协议配置示例，覆盖所有功能特性，包括基础配置、结构体使用、节点组、条件依赖、填充配置等。

## 目录

1. [基础协议配置](#基础协议配置)
2. [使用结构体的协议配置](#使用结构体的协议配置)
3. [节点组配置示例](#节点组配置示例)
4. [条件依赖配置](#条件依赖配置)
5. [填充配置示例](#填充配置示例)
6. [多层嵌套协议](#多层嵌套协议)
7. [复杂表达式示例](#复杂表达式示例)
8. [完整协议示例](#完整协议示例)

## 基础协议配置

### 1. 简单协议（不使用结构体）

直接在协议类中配置所有节点，适用于简单协议。

```java

@ProtocolDefinition(id = "simple", name = "简单协议", version = "1.0", description = "无结构体的简单协议测试")
public class SimpleProtocol {

    @ProtocolNode(id = "protocol_id", name = "协议标识", length = 16, valueType = ValueType.HEX, value = "0x1234", order = 1)
    private String protocolId;

    @ProtocolNode(id = "version", name = "协议版本", length = 8, valueType = ValueType.UINT, value = "1", order = 2)
    private Integer version;

    @ProtocolNode(id = "data_length", name = "数据长度", length = 16, valueType = ValueType.UINT, fwdExpr = "length(#data_field)", order = 3)
    private Integer dataLength;

    @ProtocolNode(id = "data_field", name = "数据域", length = 4 * 8, valueType = ValueType.HEX, order = 4)
    private String dataField;

    @ProtocolNode(id = "checksum", name = "校验和", length = 16, valueType = ValueType.HEX, fwdExpr = "crc16(#data_field)", order = 5)
    private String checksum;
}
```

### 2. 带枚举的协议

```java

@ProtocolDefinition(id = "enum", name = "枚举协议", version = "1.0", description = "枚举协议测试")
public class EnumProtocol {

    @ProtocolNode(id = "uint", name = "无符号整型枚举", length = 8, valueType = ValueType.UINT, order = 1)
    @ProtocolEnum(values = {"0:离线", "1:在线", "2:忙碌", "3:离开"})
    private String unitType = "在线";

    @ProtocolNode(id = "int", name = "有符号整型枚举", length = 16, valueType = ValueType.INT, order = 2)
    @ProtocolEnum(values = {"0:哈哈", "1:拉拉", "2:儿子", "3:粑粑"})
    private String intType = "儿子";

    @ProtocolNode(id = "bitType", name = "二进制枚举", length = 8, valueType = ValueType.BIT, order = 3)
    @ProtocolEnum(values = {"0b00000011:哈哈", "0b00000001:拉拉", "0b00000000:儿子"})  // 注意位数要和length对应
    private String bitType = "哈哈";


    @ProtocolNode(id = "hexType", name = "十六进制枚举", length = 8, valueType = ValueType.HEX, order = 4)
    @ProtocolEnum(values = {"0x11:哈哈", "0x01:拉拉", "0x00:儿子"})
    private String hexType = "哈哈";

    @ProtocolNode(id = "floatType", name = "浮点数枚举", length = 4 * 8, valueType = ValueType.FLOAT, order = 4)
    @ProtocolEnum(values = {"0.11111:哈哈", "0.22222:拉拉", "0.3233333:儿子"})
    private String floatType = "哈哈";
}
```

## 使用结构体的协议配置

### 1. 标准三段式协议（Header + Body + Tail）

```java

@ProtocolDefinition(id = "standard_protocol", name = "标准协议", description = "包含头部、体部、尾部的标准协议")
public class StandardProtocol {

    @ProtocolHeader(id = "protocol_header", name = "协议头部",order = 1)
    private ProtocolHeader header;

    @ProtocolBody(id = "protocol_body", name = "协议体部",order = 2)
    private ProtocolBody body;

    @ProtocolTail(id = "protocol_tail", name = "协议尾部",order = 3)
    private ProtocolTail tail;
}

public class ProtocolHeader {

    @ProtocolNode(id = "magic_number", name = "魔数", length = 32, valueType = ValueType.HEX, value = "0xDEADBEEF", order = 1)
    private String magicNumber;

    @ProtocolNode(id = "protocol_version", name = "协议版本", length = 8, valueType = ValueType.UINT, value = "1", order = 2)
    private Integer protocolVersion;

    @ProtocolNode(id = "flags", name = "标志位", length = 8, valueType = ValueType.HEX, order = 3)
    private String flags;

    @ProtocolNode(id = "sequence_number", name = "序列号", length = 32, valueType = ValueType.UINT, order = 4)
    private Integer sequenceNumber;

    @ProtocolNode(id = "reserved", name = "保留字段", length = 32, valueType = ValueType.HEX, value = "0x00000000", order = 5)
    private String reserved;

    @ProtocolNode(id = "body_length", name = "体部长度", length = 32, valueType = ValueType.UINT, fwdExpr = "length(#body)", order = 6)
    private Integer bodyLength;
}

public class ProtocolBody {

    @ProtocolNode(id = "body_type", name = "体部类型", length = 16, valueType = ValueType.UINT, order = 1)
    private Integer bodyType;

    @ProtocolNode(id = "payload", name = "载荷数据", length = 960, valueType = ValueType.HEX, order = 2)
    private String payload;
}

public class ProtocolTail {

    @ProtocolNode(id = "checksum", name = "校验和", length = 32, valueType = ValueType.HEX, fwdExpr = "crc16(#protocol_body)", order = 1)
    private String checksum;

    @ProtocolNode(id = "end_marker", name = "结束标记", length = 32, valueType = ValueType.HEX, value = "0xCAFEBABE", order = 2)
    private String endMarker;
}
```

## 节点组配置示例

### 1. 简单节点组（扁平化策略）

```java

@ProtocolBody(
    id = "node_group_body",
    name = "节点组体部"
)
public class NodeGroupBody {

    @ProtocolNode(
        id = "group_count",
        name = "组数量",
        length = 16,
        valueType = ValueType.UINT,
        order = 1
    )
    private Integer groupCount;

    @ProtocolNodeGroup(
        id = "data_groups",
        name = "数据组",
        repeatExpr = "#group_count",
        elementType = GroupElementType.NODE,
        resolveStrategy = GroupResolveStrategy.FLATTEN,
        order = 2
    )
    private List<DataGroupItem> dataGroups;
}

public class DataGroupItem {

    @ProtocolNode(
        id = "item_id",
        name = "项目ID",
        length = 16,
        valueType = ValueType.HEX,
        order = 1
    )
    private String itemId;

    @ProtocolNode(
        id = "item_length",
        name = "项目长度",
        length = 16,
        valueType = ValueType.UINT,
        fwdExpr = "length(#item_data)",
        order = 2
    )
    private Integer itemLength;

    @ProtocolNode(
        id = "item_data",
        name = "项目数据",
        length = 128,
        valueType = ValueType.HEX,
        order = 3
    )
    private String itemData;
}
```

### 2. 协议对象组（分组容器策略）

```java

@ProtocolBody(
    id = "protocol_group_body",
    name = "协议对象组体部"
)
public class ProtocolGroupBody {

    @ProtocolNode(
        id = "sensor_count",
        name = "传感器数量",
        length = 8,
        valueType = ValueType.UINT,
        order = 1
    )
    private Integer sensorCount;

    @ProtocolNodeGroup(
        id = "sensor_groups",
        name = "传感器组",
        repeatExpr = "#sensor_count",
        elementType = GroupElementType.PROTOCOL_OBJECT,
        resolveStrategy = GroupResolveStrategy.GROUP_CONTAINER,
        order = 2
    )
    private List<SensorProtocol> sensorGroups;
}

@ProtocolDefinition(
    id = "sensor_protocol",
    name = "传感器协议"
)
public class SensorProtocol {

    @ProtocolNode(
        id = "sensor_id",
        name = "传感器ID",
        length = 16,
        valueType = ValueType.HEX,
        order = 1
    )
    private String sensorId;

    @ProtocolNode(
        id = "sensor_type",
        name = "传感器类型",
        length = 8,
        valueType = ValueType.UINT,
        order = 2
    )
    private Integer sensorType;

    @ProtocolNode(
        id = "sensor_data",
        name = "传感器数据",
        length = 64,
        valueType = ValueType.FLOAT,
        endian = EndianType.LITTLE,
        order = 3
    )
    private Float sensorData;

    @ProtocolNode(
        id = "sensor_status",
        name = "传感器状态",
        length = 8,
        valueType = ValueType.HEX,
        order = 4
    )
    private String sensorStatus;
}
```

## 条件依赖配置

### 1. 基本条件依赖

```java

@ProtocolBody(
    id = "conditional_body",
    name = "条件依赖体部"
)
public class ConditionalBody {

    @ProtocolNode(
        id = "protocol_type",
        name = "协议类型",
        length = 8,
        valueType = ValueType.UINT,
        order = 1
    )
    private Integer protocolType;

    @ProtocolNode(
        id = "extended_data",
        name = "扩展数据",
        length = 256,
        valueType = ValueType.HEX,
        order = 2,
        optional = true
    )
    @ConditionalDependency(
        conditionNode = "#protocol_type",
        condition = "value == 1",
        action = ConditionalAction.ENABLE,
        elseAction = ConditionalAction.DISABLE,
        priority = 1
    )
    private String extendedData;

    @ProtocolNode(
        id = "control_flags",
        name = "控制标志",
        length = 32,
        valueType = ValueType.HEX,
        order = 3,
        optional = true
    )
    @ConditionalDependency(
        conditionNode = "#protocol_type",
        condition = "value in [2, 3, 4]",
        action = ConditionalAction.ENABLE,
        elseAction = ConditionalAction.DISABLE,
        priority = 2
    )
    private String controlFlags;
}
```

## 填充配置示例

### 1. 固定长度填充

```java

@ProtocolBody(
    id = "padding_body",
    name = "填充体部"
)
public class PaddingBody {

    @ProtocolNode(
        id = "data_field",
        name = "数据字段",
        length = 64,
        valueType = ValueType.HEX,
        order = 1
    )
    private String dataField;

    @ProtocolNode(
        id = "padding_field",
        name = "填充字段",
        length = 0,
        valueType = ValueType.HEX,
        order = 2
    )
    @Padding(
        paddingType = PaddingType.FIXED_LENGTH,
        targetLength = 256,
        paddingValue = "0x00",
        repeatPattern = true
    )
    private String paddingField;
}
```

### 2. 对齐填充

```java

@ProtocolBody(
    id = "alignment_body",
    name = "对齐填充体部"
)
public class AlignmentBody {

    @ProtocolNode(
        id = "variable_data",
        name = "可变数据",
        length = 0,
        valueType = ValueType.HEX,
        fwdExpr = "length(#data_content)",
        order = 1
    )
    private String variableData;

    @ProtocolNode(
        id = "alignment_padding",
        name = "对齐填充",
        length = 0,
        valueType = ValueType.HEX,
        order = 2
    )
    @Padding(
        paddingType = PaddingType.ALIGNMENT,
        targetLength = 64,
        paddingValue = "0x00"
    )
    private String alignmentPadding;
}
```

## 总结

本文档展示了协议配置的主要功能特性：

1. **基础配置**：字段定义、类型、长度、字节序等
2. **结构体使用**：Header、Body、Tail的分离和组合
3. **节点组**：支持重复、嵌套、多种解析策略
4. **条件依赖**：基于表达式的条件启用/禁用
5. **填充配置**：固定长度、对齐等填充策略

这些示例涵盖了从简单到复杂的各种协议配置场景，可以作为实际项目开发的参考模板。
